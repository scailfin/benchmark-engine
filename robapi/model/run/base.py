# This file is part of the Reproducible Open Benchmarks for Data Analysis
# Platform (ROB).
#
# Copyright (C) 2019 NYU.
#
# ROB is free software; you can redistribute it and/or modify it under the
# terms of the MIT License; see LICENSE file for more details.

"""Run handles provide access to run states."""

import json

from robtmpl.workflow.resource import FileResource
from robtmpl.workflow.state.base import (
    StatePending, StateCanceled, StateError, StateRunning, StateSuccess
)

import robapi.model.base as base
import robtmpl.workflow.state.base as st
import robtmpl.util as util


class RunHandle(object):
    """Basic information about workflow runs. Maintains the run identifier and
    the current run state.
    """
    def __init__(self, identifier, submission_id, benchmark_id, state, arguments):
        """Initialize the object properties.

        Parameters
        ----------
        identifier: string
            Unique run identifier
        submission_id: string
            Unique identifier of the submission
        benchmark_id: string
            Unique benchmark identifier
        state: robtmpl.workflow.state.base.WorkflowState
            Current workflow run state
        arguments: dict()
            Dictionary of user-provided argument values for the run
        """
        self.identifier = identifier
        self.submission_id = submission_id
        self.benchmark_id = benchmark_id
        self.state = state
        self.arguments = arguments

    @staticmethod
    def from_db(doc, con):
        """Create an instance of the run handle from a dictionary, e.g., a row
        in the result set of a database query.

        Expects the following identifier in the result dictionary: run_id,
        benchmark_id, and submission_id. For the run state the following
        elements are expected: state, ctreate_at, started_at, and ended_at.

        Additional information for the respective run states is retrieved by
        querying the underlying database.

        Parameters
        ----------
        doc: dict
            Dictionary containing identifier and run state information
        con: DB-API 2.0 database connection
            Connection to the underlying database

        Returns
        -------
        robapi.model.run.base.RunHandle
        """
        run_id = doc['run_id']
        benchmark_id = doc['benchmark_id']
        submission_id = doc['submission_id']
        type_id = doc['state']
        created_at = util.to_datetime(doc['created_at'])
        started_at = util.to_datetime(doc['started_at'])
        ended_at = util.to_datetime(doc['ended_at'])
        arguments = doc['arguments']
        if type_id == st.STATE_PENDING:
            state = StatePending(created_at=created_at)
        elif type_id == st.STATE_RUNNING:
            state = StateRunning(
                created_at=created_at,
                started_at=started_at
            )
        elif type_id in [st.STATE_CANCELED, st.STATE_ERROR]:
            # Read error messages from the database
            messages = list()
            sql = 'SELECT * FROM run_error_log WHERE run_id = ? ORDER BY pos'
            for msg in con.execute(sql, (run_id,)).fetchall():
                messages.append(msg['message'])
            if type_id == st.STATE_CANCELED:
                state = StateCanceled(
                    created_at=created_at,
                    started_at=started_at,
                    stopped_at=ended_at,
                    messages=messages
                )
            else:
                state = StateError(
                    created_at=created_at,
                    started_at=started_at,
                    stopped_at=ended_at,
                    messages=messages
                )
        else: # type_id == state.STATE_SUCCESS:
            # Read file resources that were generated by the run
            files = dict()
            # run_result_file
            sql = 'SELECT * FROM run_result_file WHERE run_id = ?'
            for f in con.execute(sql, (run_id,)).fetchall():
                file_id = f['file_id']
                files[file_id] = FileResource(file_id, f['file_path'])
            state = StateSuccess(
                created_at=created_at,
                started_at=started_at,
                finished_at=ended_at,
                files=files
            )
        # Create and return run handle
        return RunHandle(
            identifier=run_id,
            submission_id=submission_id,
            benchmark_id=benchmark_id,
            state=state,
            arguments=json.loads(arguments)
        )

    def get_files(self):
        """Shortcut to access all associated file resources.

        Returns
        -------
        list(robtmpl.workflow.resource.FileResource)
        """
        if not self.is_success():
            return list()
        else:
            return self.state.files.values()

    def is_active(self):
        """A run is in active state if it is either pending or running.

        Returns
        --------
        bool
        """
        return self.state.is_active()

    def is_canceled(self):
        """Returns True if the workflow state is of type CANCELED.

        Returns
        -------
        bool
        """
        return self.state.is_canceled()

    def is_error(self):
        """Returns True if the workflow state is of type ERROR.

        Returns
        -------
        bool
        """
        return self.state.is_error()

    def is_pending(self):
        """Returns True if the workflow state is of type PENDING.

        Returns
        -------
        bool
        """
        return self.state.is_pending()

    def is_running(self):
        """Returns True if the workflow state is of type RUNNING.

        Returns
        -------
        bool
        """
        return self.state.is_running()

    def is_success(self):
        """Returns True if the workflow state is of type SUCCESS.

        Returns
        -------
        bool
        """
        return self.state.is_success()

    def result_table(self):
        """Name of the result table for the benchmark that is associated with
        the run.

        Returns
        -------
        string
        """
        return base.RESULT_TABLE(self.benchmark_id)
